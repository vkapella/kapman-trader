STORY A6.1 — Options Snapshot Storage on TimescaleDB

Objective

Rebuild the KapMan database schema so that options snapshot data is stored as a TimescaleDB hypertable, governed by native retention and compression policies, aligned with the existing OHLCV time-series architecture.

This story finalizes the long-term data model for options by treating option contracts as implicit, time-scoped facts, not durable entities.

At completion, the database can be destroyed and deterministically rebuilt, fully rehydrated, and verified.

⸻

Design Decisions (Non-Negotiable)

✅ What We Will Do
	•	Store options snapshots in a TimescaleDB hypertable
	•	Use TimescaleDB retention policies for lifecycle management
	•	Align retention window with OHLCV (currently 730 days)
	•	Treat option contracts as implicit (derived from snapshot rows)
	•	Use snapshot_time as the primary time dimension
	•	Support idempotent re-ingestion via deterministic upserts

❌ What We Will Not Do
	•	❌ No cron-based cleanup jobs
	•	❌ No separate options_contracts table
	•	❌ No long-lived contract identity outside snapshots
	•	❌ No manual deletion of expired contracts

⸻

Schema Changes

New Hypertable: options_chains

Purpose: Store point-in-time option snapshots for all symbols.

Time Dimension
	•	time TIMESTAMPTZ NOT NULL (snapshot_time)

Primary Identifiers
	•	ticker_id UUID NOT NULL
	•	expiration_date DATE NOT NULL
	•	strike_price NUMERIC(12,4) NOT NULL
	•	option_type CHAR(1) NOT NULL (C / P)

Market Data
	•	bid NUMERIC
	•	ask NUMERIC
	•	last NUMERIC
	•	volume INTEGER
	•	open_interest INTEGER
	•	implied_volatility NUMERIC

Greeks
	•	delta NUMERIC
	•	gamma NUMERIC
	•	theta NUMERIC
	•	vega NUMERIC

Metadata
	•	created_at TIMESTAMPTZ NOT NULL DEFAULT now()

⸻

Indexing & Constraints
	•	Composite unique constraint:

(time, ticker_id, expiration_date, strike_price, option_type)


	•	Supporting indexes:
	•	(ticker_id, time DESC)
	•	(expiration_date)
	•	(time DESC)

⸻

TimescaleDB Configuration

Hypertable Creation
	•	Convert options_chains to hypertable on time
	•	Chunk interval aligned with OHLCV (e.g., daily or weekly)

Retention Policy
	•	Retention: 730 days
	•	Schedule: Daily
	•	Mechanism: add_retention_policy()

Compression Policy
	•	Enable compression
	•	Compress chunks older than a defined threshold of 120 days	
	•	Segment by ticker_id
	•	Order by time DESC

⸻

Ingestion Semantics
	•	Each ingestion run writes a complete snapshot for a symbol
	•	Older snapshots automatically age out via retention
	•	Expired contracts disappear naturally when their last snapshot ages out
	•	No explicit “contract deletion” logic exists anywhere in the system

⸻

Destructive Validation Requirement

This story is not complete unless the following destructive test is executed and verified:

Step 1 — Destroy Database
	•	Drop the existing KapMan database completely

Step 2 — Recreate Schema
	•	Reapply all migrations
	•	Confirm:
	•	ohlcv hypertable exists
	•	options_chains hypertable exists
	•	Retention policy is attached to both

Step 3 — Rehydrate Core Data
	•	Rehydrate:
	•	tickers
	•	watchlists
	•	ohlcv
	•	options_chains

Step 4 — Verification Queries
	•	Confirm TimescaleDB recognizes options_chains as a hypertable
	•	Confirm retention job exists and matches OHLCV policy
	•	Confirm options data is queryable by:
	•	time
	•	ticker
	•	expiration_date

---

Executable Validation (Repo Commands)

Step 1–2 (Destroy + Recreate + Schema Verification)

	•	`python3 scripts/db/a6_1_destroy_recreate_verify.py`

Step 3 (Rehydrate, in order)

	•	`python3 scripts/ingest_tickers.py`
	•	`python3 scripts/ingest_watchlists.py`
	•	`python3 scripts/ingest_ohlcv.py`
	•	`python3 scripts/ingest_options.py`

Step 4 (Manual SQL Spot-Checks)

	•	`SELECT * FROM timescaledb_information.hypertables WHERE hypertable_name IN ('ohlcv','options_chains');`
	•	`SELECT hypertable_name, proc_name, config FROM timescaledb_information.jobs WHERE hypertable_name IN ('ohlcv','options_chains');`

⸻

Acceptance Criteria
	•	✅ options_chains is a TimescaleDB hypertable
	•	✅ Retention policy exists and is active
	•	✅ Compression policy exists (if enabled for OHLCV)
	•	✅ No standalone contracts table exists
	•	✅ Full ingest runs complete successfully after DB rebuild
	•	✅ Expired options naturally disappear as snapshots age out
	•	✅ Story A6.1 and Story A1 can both be closed

⸻

Dependencies
	•	Requires completion of:
	•	A5 / A6 baseline schema story
	•	Deterministic OHLCV ingestion (A0)
	•	Options snapshot ingestion pipeline (current implementation)

⸻

Outcome

After this story:
	•	Options storage is architecturally consistent with OHLCV
	•	Data lifecycle is self-managing
	•	No manual cleanup logic exists
	•	The schema supports high-volume, long-running, repeatable ingestion
	•	KapMan has a clean, production-grade time-series model for options

⸻
