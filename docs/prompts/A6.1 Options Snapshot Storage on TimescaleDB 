You are implementing STORY A6.1 — Options Snapshot Storage on TimescaleDB in the KapMan repository. This is a destructive, schema-level change and must be implemented deterministically, end-to-end, with zero ambiguity.

You must produce code changes, migrations, and validation steps so that the database can be dropped, recreated, rehydrated, and verified exactly as described below.

Do not invent alternative designs. Do not preserve legacy behavior that conflicts with this story. Treat the requirements as non-negotiable.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
OBJECTIVE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Rebuild the KapMan database schema so that options snapshot data is stored in a TimescaleDB hypertable with native retention and compression policies, aligned with the existing OHLCV architecture.

Option contracts are implicit, time-scoped facts derived from snapshots. They are not durable entities.

At completion:
	•	The database can be destroyed and rebuilt
	•	All core data can be rehydrated
	•	Options snapshots are stored and managed entirely via TimescaleDB policies
	•	Story A6.1 and Story A1 are both closable

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
HARD DESIGN CONSTRAINTS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

YOU MUST DO:
	•	Store options snapshots in a TimescaleDB hypertable named options_chains
	•	Use snapshot_time as the hypertable time dimension
	•	Use TimescaleDB retention policies (no cron, no manual cleanup)
	•	Align retention window with OHLCV (730 days)
	•	Enable compression with segmenting by ticker_id
	•	Treat option contracts as implicit (derived from snapshot rows only)
	•	Support deterministic, idempotent ingestion via upserts

YOU MUST NOT DO:
	•	Do NOT create an options_contracts table
	•	Do NOT store long-lived contract entities
	•	Do NOT use cron jobs for cleanup
	•	Do NOT implement explicit deletion of expired contracts
	•	Do NOT keep legacy schema behavior that conflicts with this model

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
SCHEMA — options_chains (FINAL)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Create a new table options_chains with the following exact columns:

time TIMESTAMPTZ NOT NULL                    – snapshot_time
ticker_id UUID NOT NULL
expiration_date DATE NOT NULL
strike_price NUMERIC(12,4) NOT NULL
option_type CHAR(1) NOT NULL                 – ‘C’ or ‘P’

bid NUMERIC
ask NUMERIC
last NUMERIC
volume INTEGER
open_interest INTEGER
implied_volatility NUMERIC

delta NUMERIC
gamma NUMERIC
theta NUMERIC
vega NUMERIC

created_at TIMESTAMPTZ NOT NULL DEFAULT now()

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
CONSTRAINTS & INDEXES
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Define a composite UNIQUE constraint exactly on:
(time, ticker_id, expiration_date, strike_price, option_type)

Create the following supporting indexes:
	•	(ticker_id, time DESC)
	•	(expiration_date)
	•	(time DESC)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
TIMESCALEDB CONFIGURATION
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

After table creation:
	1.	Convert options_chains to a hypertable:
	•	Time column: time
	•	Chunk interval aligned with OHLCV (daily or weekly, match existing policy)
	2.	Retention policy:
	•	Retain 730 days
	•	Schedule daily
	•	Use add_retention_policy()
	3.	Compression:
	•	Enable compression
	•	Compress chunks older than 120 days
	•	Segment by ticker_id
	•	Order by time DESC
	•	Use add_compression_policy()

Compression must match OHLCV behavior if compression is already enabled there.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
INGESTION SEMANTICS (MANDATORY)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
	•	Each ingestion run writes a full snapshot per symbol
	•	Ingestion uses deterministic upserts against the composite key
	•	Re-ingestion of the same snapshot_time is idempotent
	•	No ingestion logic performs deletions
	•	Expired contracts disappear naturally when their last snapshot ages out
	•	No logic anywhere references “contract expiration” for deletion

If any ingestion code assumes a contracts table or durable contract identity, it must be removed or refactored.

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
MIGRATIONS & DESTRUCTIVE FLOW
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

You must implement migrations such that the following destructive validation is possible and succeeds:

STEP 1 — DESTROY
	•	Drop the KapMan database completely

STEP 2 — RECREATE
	•	Reapply all migrations from scratch
	•	Confirm via SQL:
	•	ohlcv is a TimescaleDB hypertable
	•	options_chains is a TimescaleDB hypertable
	•	Retention policy exists for both and matches (730 days)

STEP 3 — REHYDRATE
	•	Rehydrate, in order:
	•	tickers
	•	watchlists
	•	ohlcv
	•	options_chains (via snapshot ingestion)

STEP 4 — VERIFY
	•	options_chains appears in timescaledb_information.hypertables
	•	Retention job exists for options_chains
	•	Compression is enabled if OHLCV compression is enabled
	•	Options data is queryable by:
	•	time
	•	ticker_id
	•	expiration_date

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ACCEPTANCE CRITERIA (ALL REQUIRED)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
	•	options_chains is a TimescaleDB hypertable
	•	Retention policy is active and visible
	•	Compression policy exists (if OHLCV is compressed)
	•	No options_contracts table exists
	•	Full ingestion succeeds after DB rebuild
	•	Expired options disappear naturally via retention
	•	No cron jobs exist for options cleanup
	•	Story A6.1 and Story A1 are both closable

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
IMPLEMENTATION GUIDANCE
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
	•	Update or add migrations as needed
	•	Remove or refactor any legacy schema assumptions
	•	Ensure provider + pipeline code aligns with the new schema
	•	Ensure logging remains accurate and non-misleading
	•	Do not add new conceptual layers or abstractions

Produce clean, production-grade code consistent with the existing KapMan architecture.

End of instructions.